{"codes": ["\nclass Solution(object):\n    def maxCells(self, r, c, grid):\n        \"\"\"\n        :type r: int\n        :type c: int\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def dfs(i, j):\n            if i < 0 or i >= r or j < 0 or j >= c or grid[i][j] == 'X':\n                return 0\n            if grid[i][j] == '.':\n                grid[i][j] = 'X'\n                return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\n            else:\n                return 0\n\n        res = 0\n        for i in range(r):\n            for j in range(c):\n                res = max(res, dfs(i, j))\n        return res\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "import math\nimport os\nimport random\nimport re\nimport sys\n\n\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    rc = input().split()\n\n    r = int(rc[0])\n\n    c = int(rc[1])\n\n    grid = []\n\n    for _ in range(r):\n        grid_item = input()\n        grid.append(grid_item)\n\n    result = solve(r, c, grid)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```", "class Solution(object):\n    def maxCells(self, r, c):\n        \"\"\"\n        :type r: int\n        :type c: int\n        :rtype: int\n        \"\"\"", "import sys\n\nr, c = map(int, sys.stdin.readline().split())\ngrid = []\nfor i in range(r):\n    grid.append(list(sys.stdin.readline().strip()))\n\n\ndef dfs(i, j):\n    if i < 0 or i >= r or j < 0 or j >= c:\n        return 0\n    if grid[i][j] == '.':\n        grid[i][j] = 'S'\n        return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1)\n    else:\n        return 0\n\n\nres = 0\nfor i in range(r):\n    for j in range(c):\n        res = max(res, dfs(i, j))\nprint(res)", "\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    rc = input().split()\n\n    r = int(rc[0])\n\n    c = int(rc[1])\n\n    grid = []\n\n    for _ in range(r):\n        grid_item = input()\n        grid.append(grid_item)\n\n    result = solve(r, c, grid)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()", "import sys\n\n\nr, c = map(int, sys.stdin.readline().split())\ncake = []\nfor i in range(r):\n    cake.append(list(sys.stdin.readline().strip()))\n\nans = 0\nfor i in range(r):\n    for j in range(c):\n        if cake[i][j] == '.':\n            count = 0\n            for k in range(i, r):\n                if cake[k][j] == 'S':\n                    break\n                else:\n                    count += 1\n            for k in range(j, c):\n                if cake[i][k] == 'S':\n                    break\n                else:\n                    count += 1\n            ans = max(ans, count)\n\nfor i in range(c):\n    for j in range(r):\n        if cake[j][i] == '.':\n            count = 0\n            for k in range(i, c):\n                if cake[j][k] == 'S':\n                    break\n                else:\n                    count += 1\n            for k in range(j, r):\n                if cake[k][i] == 'S':\n                    break\n                else:\n                    count += 1\n            ans = max(ans, count)\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "import sys\nimport numpy as np\n\nr, c = map(int, sys.stdin.readline().split())\n\ngrid = []\n\nfor i in range(r):\n    grid.append(list(sys.stdin.readline().strip()))\n\ngrid = np.array(grid)\n\nans = 0\n\nfor i in range(r):\n    for j in range(c):\n        if grid[i, j] == '.':\n            count = 0\n            for k in range(i, r):\n                if grid[k, j] == 'S':\n                    break\n                else:\n                    count += 1\n            for k in range(j, c):\n                if grid[i, k] == 'S':\n                    break\n                else:\n                    count += 1\n            ans = max(ans, count)\n\nfor i in range(c):\n    for j in range(r):\n        if grid[j, i] == '.':\n            count = 0\n            for k in range(i, c):\n                if grid[j, k] == 'S':\n                    break\n                else:\n                    count += 1\n            for k in range(j, r):\n                if grid[k, i] == 'S':\n                    break\n                else:\n                    count += 1\n            ans = max(ans, count)\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"], "rewards": [0.0, 0.0, 0.0, 0.0, 0.42857142857142855, 0.0, 0.047619047619047616, 0.047619047619047616], "train rewards": [0.0, 0.0, 0.0, 0.0, 0.38095238095238093, 0.0, 0.19047619047619047, 0.19047619047619047], "time": [35.151822328567505, 70.77012610435486, 75.24539709091187, 85.23606538772583, 98.99398493766785, 134.39586544036865, 169.43117022514343, 204.5377368927002], "sample times": 8}