{"codes": ["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\nmaze = []\nfor i in range(n):\n    maze.append(list(sys.stdin.readline().strip()))\nstart = maze[0].index(\"X\")\nmaze[0][start] = \".\"\nfor i in range(1, n):\n    for j in range(m):\n        if maze[i][j] == \"*\":\n            maze[i][j] = \".\"\n\n\ndef find_path(x, y, path):\n    if len(path) == k:\n        return path\n    if x < 0 or x >= n or y < 0 or y >= m or maze[x][y] == \"*\":\n        return None\n    if maze[x][y] == \".\":\n        maze[x][y] = \"*\"\n        return find_path(x - 1, y, path + \"U\") or find_path(x + 1, y, path + \"D\") or find_path(\n            x, y - 1, path + \"L\"\n        ) or find_path(x, y + 1, path + \"R\")\n    return None\n\n\npath = find_path(0, start, \"\")\nif path:\n    print(path)\nelse:\n    print(\"IMPOSSIBLE\")", "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,k;\nchar a[1001][1001];\nint main()\n{\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tcin>>a[i][j];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tif(a[i][j]=='X')\n\t\t\t{\n\t\t\t\ta[i][j]='.';\n\t\t\t\tbreak;\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tif(a[i][j]=='.')\n\t\t\t{\n\t\t\t\ta[i][j]='X';\n\t\t\t\tbreak;\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tif(a[i][j]=='X')\n\t\t\t{\n\t\t\t\ta[i][j]='.';\n\t\t\t\tbreak;\n\t\t\t}\n\tfor", "\nimport sys\n\nn, m, k = map(int, sys.stdin.readline().split())\nmaze = []\nfor i in range(n):\n    maze.append(list(sys.stdin.readline().strip()))\nstart = None\nfor i in range(n):\n    for j in range(m):\n        if maze[i][j] == 'X':\n            start = (i, j)\n            maze[i][j] = '.'\n            break\nif not start:\n    print('IMPOSSIBLE')\n    sys.exit(0)\nvisited = [[False] * m for _ in range(n)]\nvisited[start[0]][start[1]] = True\nqueue = [(start[0], start[1], '')]\nwhile queue:\n    x, y, path = queue.pop(0)\n    if len(path) == k:\n        print(path)\n        sys.exit(0)\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and maze[nx][ny] == '.':\n            visited[nx][ny] = True\n            queue.append((nx, ny, path + 'L'", "\ndef dfs(i,j,k):\n    if k == 0:\n        return True\n    if i < 0 or i >= n or j < 0 or j >= m:\n        return False\n    if grid[i][j] == '*':\n        return False\n    if grid[i][j] == 'X':\n        return dfs(i,j-1,k-1) or dfs(i,j+1,k-1) or dfs(i-1,j,k-1) or dfs(i+1,j,k-1)\n    if grid[i][j] == 'L':\n        return dfs(i,j-1,k-1) or dfs(i,j+1,k-1) or dfs(i-1,j,k-1) or dfs(i+1,j,k-1)\n    if grid[i][j] == 'R':\n        return dfs(i,j-1,k-1) or dfs(i,j+1,k-1) or dfs(i-1,j,k-1) or dfs(i+1,j,k-1)\n    if grid[i][j] == 'U':\n        return dfs(i-1,j,k-1) or dfs(i+1,j,k-1) or dfs(i,j-1,k-1) or dfs(i,", "\ndef get_neighbours(x, y):\n    neighbours = []\n    if x > 0:\n        neighbours.append((x - 1, y))\n    if x < n - 1:\n        neighbours.append((x + 1, y))\n    if y > 0:\n        neighbours.append((x, y - 1))\n    if y < m - 1:\n        neighbours.append((x, y + 1))\n    return neighbours\n\n\ndef dfs(x, y, path, k):\n    if k == 0:\n        return path\n    neighbours = get_neighbours(x, y)\n    for nx, ny in neighbours:\n        if grid[nx][ny] == '.':\n            grid[nx][ny] = '*'\n            path += dfs(nx, ny, path, k - 1)\n            grid[nx][ny] = '.'\n    return path\n\n\nn, m, k = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(input()))\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 'X':\n            grid[i][j] = '.'\n            path = dfs(i, j, '', k)\n            grid[", "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int n,m,k;\n    cin>>n>>m>>k;\n    int a[n][m];\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<m;j++)\n        {\n            cin>>a[i][j];\n            if(a[i][j]=='X')\n            {\n                x=i;\n                y=j;\n            }\n        }\n    }\n    string s;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<m;j++)\n        {\n            if(a[i][j]=='*')\n            {\n                a[i][j]='.';\n            }\n        }\n    }\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<m;j++)\n        {\n            if(a[i][j]=='*')\n            {\n                a[i][j]='.';\n            }\n        }\n    }\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<m;j++)\n        {\n            if(a[i][j]=='*')\n            {\n                a"], "rewards": [0.0, 0.21739130434782608, 0.0, 0.0, 0.0, 0.0, 0.0], "train rewards": [0.0, 0.043478260869565216, 0.0, 0.0, 0.0, 0.0, 0.0], "time": [18.7889347076416, 38.277321338653564, 57.9303674697876, 77.1095221042633, 96.27056765556335, 115.76613521575928, 134.9044418334961], "sample times": 7}