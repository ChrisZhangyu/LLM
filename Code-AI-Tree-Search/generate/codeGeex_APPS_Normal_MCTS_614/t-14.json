{"codes": ["\nclass Solution(object):\n    def restoreArray(self, adjacentPairs):\n        \"\"\"\n        :type adjacentPairs: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if len(adjacentPairs) == 1:\n            return adjacentPairs[0]\n        dic = {}\n        for i in range(len(adjacentPairs)):\n            if adjacentPairs[i][0] not in dic:\n                dic[adjacentPairs[i][0]] = [adjacentPairs[i][1]]\n            else:\n                dic[adjacentPairs[i][0]].append(adjacentPairs[i][1])\n            if adjacentPairs[i][1] not in dic:\n                dic[adjacentPairs[i][1]] = [adjacentPairs[i][0]]\n            else:\n                dic[adjacentPairs[i][1]].append(adjacentPairs[i][0])\n        res = []\n        ", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "import sys\n\nn, k = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\n\nb = []\ns = []\n\nfor i in range(k):\n    s.append(a[i])\n    b.append(a[i])\n\nfor i in range(k, n):\n    if len(s) == 0:\n        s.append(a[i])\n        b.append(a[i])\n    else:\n        if a[i] > s[-1]:\n            s.append(a[i])\n            b.append(a[i])\n        else:\n            while len(s) > 0 and a[i] < s[-1]:\n                b.append(s[-1])\n                s.pop()\n            s.append(a[i])\n            b.append(a[i])\n\nif len(s) > 0:\n    while len(s) > 0:\n        b.append(s[-1])\n", "class Solution(object):\n    def restoreArray(self, adjacentPairs):\n        \"\"\"\n        :type adjacentPairs: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if len(adjacentPairs) == 1:\n            return adjacentPairs[0]\n        dic = {}\n        for i in range(len(adjacentPairs)):\n            if adjacentPairs[i][0] not in dic:\n                dic[adjacentPairs[i][0]] = [adjacentPairs[i][1]]\n            else:\n                dic[adjacentPairs[i][0]].append(adjacentPairs[i][1])\n            if adjacentPairs[i][1] not in dic:\n                dic[adjacentPairs[i][1]] = [adjacentPairs[i][0]]\n            else:\n                dic[adjacentPairs[i][1]].append(adjacentPairs[i][0])\n        for key in dic:", "\nimport sys\n\nn, k = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nb = []\ns = []\n\nfor i in range(k):\n    s.append(a[i])\n\nfor i in range(k, n):\n    if len(s) == 0:\n        b.append(a[i])\n    else:\n        b.append(s[-1])\n        s.pop()\n        s.append(a[i])\n\nfor i in range(len(s)):\n    b.append(s[-1])\n    s.pop()\n\nif b == list(range(1, n + 1)):\n    print(*b)\nelse:\n    print(-1)", "class Solution:\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\n        dic={}\n        for i in adjacentPairs:\n            if i[0] not in dic:\n                dic[i[0]]=[i[1]]\n            else:\n                dic[i[0]].append(i[1])\n            if i[1] not in dic:\n                dic[i[1]]=[i[0]]\n            else:\n                dic[i[1]].append(i[0])\n        ans=[]\n        for i in dic:\n            if len(dic[i])==1:\n                ans.append(i)\n                ans.append(dic[i][0])\n                break\n        while len(ans)<len(dic):\n            for i in dic:\n                if dic[i][0]==ans[-1]:\n                    ans.append(i)\n                    dic[i].remove(ans[-2])\n                    break\n        return", "\n\ndef is_stack_sortable(a):\n    s = []\n    b = []\n    while len(a) > 0 or len(s) > 0:\n        if len(a) > 0:\n            s.append(a.pop(0))\n        if len(s) > 0:\n            b.append(s.pop())\n    return b == sorted(b)\n\n\ndef restore_stack_sortable(a):\n    s = []\n    b = []\n    while len(a) > 0 or len(s) > 0:\n        if len(a) > 0:\n            s.append(a.pop(0))\n        if len(s) > 0:\n            b.append(s.pop())\n    return b\n\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nif is_stack_sortable(a[:k]):\n    print(*restore_stack_sortable(a))\nelse:\n    print(-1)"], "rewards": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.27472527472527475], "train rewards": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5888888888888889], "time": [13.820092678070068, 29.385224103927612, 44.51338005065918, 60.1965754032135, 75.3213279247284, 90.81841039657593, 106.7558958530426], "sample times": 7}