{"codes": ["\nclass Solution(object):\n    def restoreFloor(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m.sort(key=lambda x: x[1])\n        for i in range(len(m)):\n            if m[i][1] == n:\n                return m[i][1]\n            elif m[i][1] < n:\n                n -= m[i][1]\n            else:\n                return -1", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "import sys\n\nn, m = map(int, sys.stdin.readline().split())\nfloor = [0] * 101\nfor i in range(m):\n    k, f = map(int, sys.stdin.readline().split())\n    floor[k] = f\n\nfor i in range(n, 101):\n    if floor[i] != 0:\n        print(floor[i])\n        break\nelse:\n    print(-1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\ndef floor(n, m):\n    floor_list = []\n    for i in range(1, m + 1):\n        floor_list.append(i)\n    for i in range(m + 1, n + 1):\n        floor_list.append(i)\n    for i in range(n + 1, n + m + 1):\n        floor_list.append(i)\n    floor_list.sort()\n    for i in range(1, n + 1):\n        if floor_list[i - 1] == i:\n            return floor_list[i - 1]\n    return -1\n\nn, m = map(int, input().split())\nprint(floor(n, m))", "class Solution(object):\n    def restoreFloor(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m.sort(key=lambda x:x[1])\n        for i in range(len(m)-1):\n            if m[i][1]==m[i+1][1]:\n                return -1\n        return m[n-1][1]", "import math\nimport os\nimport random\nimport re\nimport sys\n\n\n\nif __name__ == '__main__':\n    nm = input().split()\n\n    n = int(nm[0])\n\n    m = int(nm[1])\n\n    arr = []\n\n    for _ in range(m):\n        arr.append(list(map(int, input().rstrip().split())))\n\n    floor = -1\n\n    for i in range(m):\n        if arr[i][0] == n:\n            floor = arr[i][1]\n            break\n\n    if floor != -1:\n        print(floor)\n    else:\n        print(-1)", "\ndef check_floor(n, m, floors):\n    for i in range(m):\n        if floors[n - 1] == floors[n - 1 - i]:\n            return -1\n    return floors[n - 1] + 1\n\nn, m = map(int, input().split())\nfloors = list(map(int, input().split()))\nprint(check_floor(n, m, floors))\n\"\"\"\n\n\ndef check_floor(n, m, floors):\n    for i in range(m):\n        if floors[n - 1] == floors[n - 1 - i]:\n            return -1\n    return floors[n - 1] + 1\n\n\nn, m = map(int, input().split())\nfloors = list(map(int, input().split()))\nprint(check_floor(n, m, floors))"], "rewards": [0.0, 0.0, 0.6756756756756757, 0.21621621621621623, 0.0, 0.0, 0.0], "train rewards": [0.0, 0.0, 0.5833333333333334, 0.2777777777777778, 0.0, 0.0, 0.0], "time": [19.985703468322754, 40.67427325248718, 61.37347674369812, 81.52452421188354, 89.68139910697937, 100.6665449142456, 118.80946111679077], "sample times": 7}