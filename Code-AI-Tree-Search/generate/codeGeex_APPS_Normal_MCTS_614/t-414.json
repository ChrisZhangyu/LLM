{"codes": ["\nimport sys\n\nn = int(sys.stdin.readline().strip())\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in sys.stdin.readline().strip().split()])\n\ndef is_intersect(a, b):\n    return a[0] <= b[1] and b[0] <= a[1]\n\ndef is_inside(a, b):\n    return a[0] >= b[0] and a[1] <= b[1]\n\ndef is_overlap(a, b):\n    return is_intersect(a, b) and not is_inside(a, b)\n\ndef is_tree(segments):\n    if len(segments) == 1:\n        return True\n\n    for i in range(len(segments)):\n        for j in range(i + 1, len(segments)):\n            if is_overlap(segments[i], segments[j]):\n                return False\n\n    return True\n\nprint(\"YES\" if is_tree(segments) else \"NO\")", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "import sys\n\nn = int(sys.stdin.readline().strip())\nsegments = []\nfor i in range(n):\n    segments.append(list(map(int, sys.stdin.readline().strip().split())))\n\nsegments.sort(key=lambda x: (x[0], x[1]))\n\ndef is_intersect(seg1, seg2):\n    if seg1[1] < seg2[0] or seg2[1] < seg1[0]:\n        return False\n    return True\n\ndef is_inside(seg1, seg2):\n    if seg1[0] >= seg2[0] and seg1[1] <= seg2[1]:\n        return True\n    if seg2[0] >= seg1[0] and seg2[1] <= seg1[1]:\n        return True\n    return False\n\ngraph = [[] for i in range(n)]\nfor i in range(n):\n    for j in range(i + 1, n):\n        if is_intersect(segments[i], segments[j]):\n            if is_inside(segments[i], segments[j]):\n                graph[i].append(j)\n                graph[j].append(i)\n\nvisited = [False for i in range(n)]\n\ndef dfs(node):\n    visited[node] = True\n    for i in graph[node]:\n        if not visited[i]:\n            dfs(i)\n\nfor i in range(n):\n    if not visited[i]:\n        dfs(i)\n\nif sum(visited) == n:\n    print(\"", "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int n;\n    cin>>n;\n    vector<pair<int,int> >v;\n    for(int i=0;i<n;i++)\n    {\n        int l,r;\n        cin>>l>>r;\n        v.push_back(make_pair(l,r));\n    }\n    for(int i=0;i<n;i++)\n    {\n        for(int j=i+1;j<n;j++)\n        {\n            if(v[i].second>=v[j].first&&v[i].first<=v[j].second)\n            {\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n        }\n    }\n    cout<<\"YES\"<<endl;\n    return 0;\n}\n```", "\nclass Solution(object):\n    def isBalanced(self, segments):\n        \"\"\"\n        :type segments: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        n = len(segments)\n        edges = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                if self.intersect(segments[i], segments[j]):\n                    edges.add((i, j))\n                    edges.add((j, i))\n        if len(edges) == n - 1:\n            return True\n        else:\n            return False\n\n    def intersect(self, segment1, segment2):\n        if segment1[1] < segment2[0] or segment2[1] < segment1[0]:\n            return False\n        else:\n            return True\n\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    segments = []\n\n    for _ in range(n):\n        segments.append(list(map(int, input().rstrip().split())))\n\n    result = Solution().isBalanced(segments)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        l, r = map(int, sys.stdin.readline().split())\n        segments.append([l, r])\n\n    segments.sort()\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if segments[i][1] < segments[j][0] or segments[i][0] > segments[j][1]:\n                continue\n            else:\n                print(\"NO\")\n                return\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()", "\nimport sys\nimport math\n\nn = int(sys.stdin.readline().strip())\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in sys.stdin.readline().strip().split()])\n\ndef is_intersect(a, b):\n    return a[0] <= b[1] and b[0] <= a[1]\n\ndef is_inside(a, b):\n    return a[0] >= b[0] and a[1] <= b[1]\n\ndef is_overlap(a, b):\n    return is_intersect(a, b) and not is_inside(a, b)\n\ndef is_tree(segments):\n    if len(segments) == 1:\n        return True\n\n    for i in range(len(segments)):\n        for j in range(i + 1, len(segments)):\n            if is_overlap(segments[i], segments[j]):\n                return False\n    return True\n\nprint(\"YES\" if is_tree(segments) else \"NO\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"], "rewards": [0.6923076923076923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6923076923076923], "train rewards": [0.64, 0.0, 0.0, 0.0, 0.0, 0.0, 0.64], "time": [15.287466526031494, 19.745335578918457, 41.80158472061157, 55.0923547744751, 77.08295059204102, 98.74771332740784, 121.02155065536499], "sample times": 7}