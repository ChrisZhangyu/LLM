{"codes": ["\nimport math\n\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef extended_gcd(a, b):\n    if b == 0:\n        return 1, 0, a\n    else:\n        x, y, gcd = extended_gcd(b, a % b)\n        x, y = y, x - (a // b) * y\n        return x, y, gcd\n\ndef modinv(a, m):\n    x, y, gcd = extended_gcd(a, m)\n    if gcd == 1:\n        return x % m\n    else:\n        return -1\n\nn, k = map(int, input().split())\n\np, q, gcd = extended_gcd(n, 1000000007)\n\nif gcd != 1:\n    print(-1)\nelse:\n    print((p * modinv(q, 1000000007)) % 1000000007)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "import fractions\n\nn, k = map(int, input().split())\n\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef extended_gcd(a, b):\n    x, y, u, v = 0, 1, 1, 0\n    while b != 0:\n        q, r = divmod(a, b)\n        a, b, x, y, u, v = b, r, x - q * u, y - q * v, u, v\n    return a, x, y\n\ndef modinv(a, m):\n    g, x, y = extended_gcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\np = 58\nq = 1000000007 - 58\n\nprint((p * modinv(q, 1000000007)) % 1000000007)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "from fractions import gcd\nfrom random import randint\n\nn, k = map(int, input().split())\np = 1\nq = 1\nfor i in range(1, k + 1):\n    v = n\n    while v > 1:\n        d = randint(1, v)\n        if d == v:\n            d = v - 1\n        v //= d\n    p *= d\n    q *= v\nprint(p * pow(q, -1, 1000000007) % 1000000007)", "import sys\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef extended_gcd(a, b):\n    if b == 0:\n        return 1, 0, a\n    else:\n        x, y, q = extended_gcd(b, a % b)\n        x, y = y, (x - (a // b) * y)\n        return x, y, q\n\ndef modinv(a, m):\n    x, y, q = extended_gcd(a, m)\n    if x < 0:\n        x += m\n    return x % m\n\nn, k = map(int, sys.stdin.readline().split())\n\np, q, r = extended_gcd(58, 1000000007)\n\nprint((p * modinv(q, 1000000007)) % 1000000007)", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```", "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef extended_gcd(a, b):\n    x, y, u, v = 0, 1, 1, 0\n    while a != 0:\n        q, r = b // a, b % a\n        m, n = x - u * q, y - v * q\n        b, a, x, y, u, v = a, r, u, v, m, n\n    return b, x, y\n\ndef modinv(a, m):\n    g, x, y = extended_gcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\nn, k = map(int, input().split())\np = 1\nq = 1\nfor i in range(2, n + 1):\n    if n % i == 0:\n        p = lcm(p, i)\n        while n % i == 0:\n            n = n // i\n        q = lcm(q, i)\n        while n % i == 0:\n            n = n // i\nprint((p * modinv(q, 1000000007)) % 1000000007)", "\nimport sys\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef extended_gcd(a, b):\n    if b == 0:\n        return 1, 0, a\n    else:\n        x, y, q = extended_gcd(b, a % b)\n        x, y = y, (x - (a // b) * y)\n        return x, y, q\n\ndef modinv(a, m):\n    x, y, q = extended_gcd(a, m)\n    if x < 0:\n        x += m\n    return x % m\n\nn, k = map(int, sys.stdin.readline().split())\np, q, r = extended_gcd(58, 1000000007)\nprint((p * modinv(q, 1000000007)) % 1000000007)", "\nfrom fractions import gcd\nfrom random import randint\n\nn, k = map(int, input().split())\n\ndef get_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    return divisors\n\ndef get_random_divisor(n):\n    divisors = get_divisors(n)\n    return divisors[randint(0, len(divisors) - 1)]\n\nans = 0\nfor i in range(k):\n    ans += get_random_divisor(n)\n    n = get_random_divisor(n)\n\nprint(gcd(ans, 1000000007))"], "rewards": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "train rewards": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "time": [27.826081037521362, 53.79315805435181, 64.46456980705261, 79.54467558860779, 85.79345202445984, 111.77321887016296, 135.60263633728027, 152.2618443965912], "sample times": 8}