{"codes": ["\nimport sys\n\nn = int(sys.stdin.readline().strip())\nshows = []\nfor i in range(n):\n    shows.append(list(map(int, sys.stdin.readline().strip().split())))\nshows.sort(key=lambda x: (x[1], x[0]))\nstart = 0\nend = 0\nfor i in range(n):\n    if shows[i][0] >= end:\n        start = shows[i][0]\n        end = shows[i][1]\n    else:\n        print(\"NO\")\n        sys.exit(0)\nprint(\"YES\")\nsys.exit(0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n\n-----Input-----\n\nThe first line contains one integer n (1 \u2264 n \u2264 2\u00b710^5) \u2014 the number of shows.\n\nEach of the next n lines contains two integers l_{i} and r_{i} (0 \u2264 l_{i} < r_{i} \u2264 10^9) \u2014 starting and ending time of i-th show.\n\n\n-----Output-----\n\nIf Polycarp is able to check out all the shows using only two TVs then print \"YES\" (without quotes). Otherwise, print \"NO\" (without quotes).\n\n\n-----Examples-----\nInput\n3\n1 2\n2 3\n4 5\n\nOutput\nYES\n\nInput\n4\n1 2\n2 3\n2 3\n1 2\n\nOutput\nNO\nUse Standard Input format\n\n\"\"\"\n\n\ndef main():\n    n = int(input())\n    l = []\n    r = []\n    for i in range(n):\n        l.append(int(input()))\n        r.append(int(input()))\n    l.sort()\n    r.sort()\n    for i in range(n - 1):\n        if l[i + 1] < r[i]:\n            print(\"NO\")\n            return\n    print(\"YES\")\n\n\nif __name__ == \"__main__\":\n    main()", "import sys\n\nn = int(sys.stdin.readline().strip())\nl = []\nr = []\nfor i in range(n):\n    l.append(int(sys.stdin.readline().strip()))\n    r.append(int(sys.stdin.readline().strip()))\n\nl.sort()\nr.sort()\n\ni = 0\nj = 0\ncount = 0\nwhile i < n and j < n:\n    if l[i] < r[j]:\n        count += 1\n        i += 1\n    else:\n        j += 1\n\nif count == n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin>>n;\n\tvector<pair<int,int> >a;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\ta.push_back(make_pair(l,r));\n\t}\n\tsort(a.begin(),a.end());\n\tint l=a[0].first,r=a[0].second;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(a[i].first>r)\n\t\t{\n\t\t\tl=a[i].first;\n\t\t\tr=a[i].second;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(a[i].second>r)\n\t\t\t\tr=a[i].second;\n\t\t}\n\t}\n\tif(r-l>=n)\n\t\tcout<<\"YES\"<<endl;\n\telse\n\t\tcout<<\"NO\"<<endl;\n\treturn 0;\n}\n```", "\ndef two_tvs_enough(shows):\n    shows = sorted(shows, key=lambda x: x[0])\n    for i in range(1, len(shows)):\n        if shows[i][0] < shows[i - 1][1]:\n            return False\n    return True\n\n\nif __name__ == '__main__':\n    n = int(input())\n    shows = []\n    for i in range(n):\n        shows.append(list(map(int, input().split())))\n    if two_tvs_enough(shows):\n        print('YES')\n    else:\n        print('NO')\n\n\"\"\"\n\n\ndef two_tvs_enough(shows):\n    shows = sorted(shows, key=lambda x: x[0])\n    for i in range(1, len(shows)):\n        if shows[i][0] < shows[i - 1][1]:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    shows = []\n    for i in range(n):\n        shows.append(list(map(int, input().split())))\n    if two_tvs_enough(shows):\n        print(\"YES\")\n    else:\n        print(\"NO\")", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\ndef solution(n, l, r):\n    l = sorted(l)\n    r = sorted(r)\n    i = 0\n    j = 0\n    while i < n and j < n:\n        if l[i] < r[j]:\n            i += 1\n        else:\n            j += 1\n    if i == n:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ndef solution(n, l, r):\n    l = sorted(l)\n    r = sorted(r)\n    i = 0\n    j = 0\n    while i < n and j < n:\n        if l[i] < r[j]:\n            i += 1\n        else:\n            j += 1\n    return \"YES\" if i == n else \"NO\"\n\n\ndef solution(n, l, r):\n    l = sorted(l)\n    r = sorted(r)\n    i = 0\n    j = 0\n    while i < n and j < n:\n        if l[i] < r[j]:\n            i += 1\n        else:\n            j += 1\n    return \"YES\" if i == n else \"NO\"\n\n\ndef solution(n, l, r):\n    l = sorted(l)\n    r = sorted(r)\n    i = 0\n    j = 0\n    while i < n and j < n:\n        if l[i] < r[j]:\n            i += 1\n        else:\n            j += 1\n    return \"YES\" if i == n else \"NO\"", "\n\ndef two_tvs_enough(shows):\n    shows.sort(key=lambda x: x[1])\n    # print(shows)\n    tv1, tv2 = 0, 1\n    while tv2 < len(shows):\n        if shows[tv1][1] < shows[tv2][0]:\n            tv1 += 1\n            tv2 += 1\n        elif shows[tv1][1] < shows[tv2][1]:\n            tv1 += 1\n        elif shows[tv1][1] == shows[tv2][1]:\n            tv1 += 1\n            tv2 += 1\n        elif shows[tv1][1] > shows[tv2][1]:\n            tv2 += 1\n        if tv1 == tv2:\n            tv1 += 1\n            tv2 += 1\n        # print(tv1, tv2)\n    if tv1 == len(shows):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\nprint(two_tvs_enough([[1, 2], [2, 3], [4, 5]]))\nprint(two_tvs_enough([[1, 2], [2, 3], [2, 3], [1, 2]]))\nprint(two_tvs_enough([[1, 2], [2, 3], [3, 4], [4, 5]]))\nprint(two_tvs_enough([[1, 2], [2, 3], [3, 4], [5, 6]]))\nprint(two_tvs_enough([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]))\nprint(two_tvs_enough([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7]]))\nprint(two_tvs_enough([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8]]))\nprint(two_tvs_enough([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9]]))"], "rewards": [0.47619047619047616, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "train rewards": [0.47619047619047616, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "time": [35.36768627166748, 55.624388456344604, 91.83223819732666, 108.1907913684845, 126.62936782836914, 162.792809009552, 183.93188428878784, 215.36564946174622], "sample times": 8}