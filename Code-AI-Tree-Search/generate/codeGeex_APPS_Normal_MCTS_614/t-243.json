{"codes": ["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```", "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nint n,m,k,x[maxn],dis[maxn];\nvector<pair<int,int> >g[maxn];\nvoid dfs(int u,int fa){\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i].first,w=g[u][i].second;\n\t\tif(v==fa)continue;\n\t\tdis[v]=max(dis[u],w);\n\t\tdfs(v,u);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=1;i<=k;i++)scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tg[u].push_back(make_pair(v,w));\n\t\tg[v].push_back(make_pair(u,w));\n\t}", "\nimport sys\n\nn, m, k = [int(x) for x in sys.stdin.readline().split()]\n\nx = [int(x) for x in sys.stdin.readline().split()]\n\nedges = []\n\nfor i in range(m):\n    u, v, w = [int(x) for x in sys.stdin.readline().split()]\n    edges.append((u, v, w))\n    edges.append((v, u, w))\n\nedges = sorted(edges, key=lambda x: x[2])\n\nd = {}\n\nfor i in range(k):\n    d[x[i]] = []\n\nfor i in range(k):\n    d[x[i]].append(x[i])\n\nfor u, v, w in edges:\n    if u in d and v in d:\n        d[u].append(v)\n        d[v].append(u)\n\nfor i in range(k):\n    d[x[i]] = sorted(d[x[i]], key=lambda x: len(d[x]), reverse=True)[0]\n\nfor i in range(k):\n    print(len(d[x[i]]) - 1)\n\n", "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\nx = list(map(int, sys.stdin.readline().split()))\n\ng = [[] for i in range(n + 1)]\nfor i in range(m):\n    u, v, w = map(int, sys.stdin.readline().split())\n    g[u].append((v, w))\n    g[v].append((u, w))\n\ndis = [-1] * (n + 1)\n\n\ndef bfs(s):\n    dis[s] = 0\n    q = [s]\n    while q:\n        u = q.pop(0)\n        for v, w in g[u]:\n            if dis[v] == -1:\n                dis[v] = dis[u] + w\n                q.append(v)\n\n\nbfs(1)\n\nfor i in range(1, n + 1):\n    if dis[i] == -1:\n        dis[i] = 0\n\nfor i in range(1, n + 1):\n    dis[i] = -dis[i]\n\nfor i in range(1, n + 1):\n    dis[i] = -dis", "\ndef read():\n    n, m, k = map(int, input().split())\n    x = list(map(int, input().split()))\n    edges = []\n    for _ in range(m):\n        u, v, w = map(int, input().split())\n        edges.append((u, v, w))\n    return n, m, k, x, edges\n\n\ndef dijkstra(s, edges):\n    d = [float('inf')] * (s + 1)\n    d[s] = 0\n    visited = [False] * (s + 1)\n    while True:\n        u = -1\n        for i in range(1, s + 1):\n            if not visited[i] and (u == -1 or d[i] < d[u]):\n                u = i\n        if u == -1:\n            break\n        visited[u] = True\n        for v, w in edges:\n            if not visited[v] and w + d[u] < d[v]:\n                d[v] = w + d[u]\n    return d\n\n\ndef solve():\n    n, m, k, x, edges = read()\n    d = dijkstra(n, edges)\n    for i in range", "```\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nint n,m,k,x[maxn],dis[maxn];\nvector<pair<int,int> >g[maxn];\nvoid dfs(int u,int fa){\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i].first,w=g[u][i].second;\n\t\tif(v==fa)continue;\n\t\tdis[v]=dis[u]+w;\n\t\tdfs(v,u);\n\t}\n}\nint main(){\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=k;i++)cin>>x[i];\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\tg[u].push_back(make_pair(v,w));\n\t\tg[v].push_back(make_pair(u,w));\n\t}\n\tdfs(1,0);\n\tfor(int i=1;i<=k;i++)cout<<dis"], "rewards": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "train rewards": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "time": [6.900604486465454, 24.115806579589844, 41.46664309501648, 59.01667022705078, 76.53323364257812, 93.9642117023468], "sample times": 6}